name: "CAgent Runner"
description: "Run a CAgent AI agent with a single line"
author: "Docker"
branding:
  icon: "cpu"
  color: "blue"

inputs:
  agent:
    description: "Agent identifier (e.g., jeanlaurent/pr-reviewer or path to .yaml file). Optional when pr-number is provided (uses built-in secure PR reviewer)"
    required: false
  prompt:
    description: "Prompt to pass to the agent. If not provided, uses a default based on the agent type"
    required: false
  cagent-version:
    description: "Version of cagent to use"
    required: false
    default: "v1.6.6"
  mcp-gateway:
    description: "Install mcp-gateway (true/false)"
    required: false
    default: "false"
  mcp-gateway-version:
    description: "Version of mcp-gateway to use (specifying this will enable mcp-gateway installation)"
    required: false
    default: "v0.22.0"
  anthropic-api-key:
    description: "Anthropic API key (defaults to ANTHROPIC_API_KEY secret)"
    required: false
  openai-api-key:
    description: "OpenAI API key (defaults to OPENAI_API_KEY secret)"
    required: false
  google-api-key:
    description: "Google API key for Gemini (defaults to GOOGLE_API_KEY secret)"
    required: false
  github-token:
    description: "GitHub token for API access (defaults to GITHUB_TOKEN env var)"
    required: false
  timeout:
    description: "Timeout in seconds for agent execution (0 for no timeout)"
    required: false
    default: "0"
  debug:
    description: "Enable debug mode with verbose logging (true/false)"
    required: false
    default: "false"
  working-directory:
    description: "Working directory to run the agent in"
    required: false
    default: "."
  tui:
    description: "Enable TUI mode (true/false)"
    required: false
    default: "false"
  yolo:
    description: "Enable yolo mode - auto-approve all prompts (true/false)"
    required: false
    default: "true"
  extra-args:
    description: "Additional arguments to pass to cagent run"
    required: false
    default: ""
  pr-number:
    description: "Pull request number (for PR review mode with built-in secure reviewer)"
    required: false
  max-pr-size:
    description: "Maximum PR size in lines (for PR review mode)"
    required: false
    default: "3000"

outputs:
  exit-code:
    description: "Exit code from cagent run"
    value: ${{ steps.run-agent.outputs.exit-code }}
  output-file:
    description: "Path to the output log file"
    value: ${{ steps.run-agent.outputs.output-file }}
  cagent-version:
    description: "Version of cagent that was used"
    value: ${{ steps.setup-binaries.outputs.cagent-version }}
  mcp-gateway-installed:
    description: "Whether mcp-gateway was installed (true/false)"
    value: ${{ steps.setup-binaries.outputs.mcp-installed }}
  execution-time:
    description: "Agent execution time in seconds"
    value: ${{ steps.run-agent.outputs.execution-time }}
  security-blocked:
    description: "Whether execution was blocked due to security concerns"
    value: ${{ steps.check-auth.outputs.authorized == 'false' || steps.sanitize-input.outputs.blocked == 'true' || steps.sanitize-output.outputs.leaked == 'true' }}
  secrets-detected:
    description: "Whether secrets were detected in output (checked for all modes)"
    value: ${{ steps.sanitize-output.outputs.leaked }}
  prompt-suspicious:
    description: "Whether suspicious patterns were detected in user prompt (general mode only)"
    value: ${{ steps.sanitize-prompt.outputs.suspicious }}
  input-risk-level:
    description: "Risk level of PR input (low/medium/high) - PR review mode only"
    value: ${{ steps.sanitize-input.outputs.risk-level }}

runs:
  using: "composite"
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        # Validate that either agent or pr-number is provided
        if [[ -z "${{ inputs.agent }}" && -z "${{ inputs.pr-number }}" ]]; then
          echo "::error::Either 'agent' or 'pr-number' input must be provided"
          echo "::error::  - For general agent execution: provide 'agent'"
          echo "::error::  - For PR review with built-in secure reviewer: provide 'pr-number'"
          exit 1
        fi

        # Validate cagent version format
        if ! [[ "${{ inputs.cagent-version }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
          echo "::error::Invalid cagent version format '${{ inputs.cagent-version }}'. Expected format: v1.2.3"
          exit 1
        fi

        # Validate mcp-gateway version format if it will be installed
        if [[ "${{ inputs.mcp-gateway }}" == "true" ]]; then
          if ! [[ "${{ inputs.mcp-gateway-version }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
            echo "::error::Invalid mcp-gateway version format '${{ inputs.mcp-gateway-version }}'. Expected format: v1.2.3"
            exit 1
          fi
        fi

        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "::debug::Validation passed"
          echo "::debug::agent: ${{ inputs.agent }}"
          echo "::debug::pr-number: ${{ inputs.pr-number }}"
          echo "::debug::cagent version: ${{ inputs.cagent-version }}"
          echo "::debug::mcp-gateway version: ${{ inputs.mcp-gateway-version }}"
          echo "::debug::mcp-gateway install: ${{ inputs.mcp-gateway }}"
        fi

    # ========================================
    # SECURITY: Authorization Check
    # ========================================
    - name: Check authorization
      if: inputs.pr-number != ''
      id: check-auth
      shell: bash
      env:
        ASSOCIATION: ${{ github.event.comment.author_association || github.event.pull_request.author_association || 'NONE' }}
      run: |
        # SECURITY: Only OWNER, MEMBER, and COLLABORATOR roles allowed (hardcoded)
        # Note: COLLABORATOR includes org members opening PRs from forks
        ALLOWED_ROLES='["OWNER", "MEMBER", "COLLABORATOR"]'

        echo "ğŸ”’ Security: Checking authorization for PR review..."
        ${{ github.action_path }}/security/check-auth.sh "$ASSOCIATION" "$ALLOWED_ROLES"

    # ========================================
    # SECURITY: Fetch PR Data
    # ========================================
    - name: Fetch PR data
      if: inputs.pr-number != ''
      id: fetch-pr
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token || github.token }}
        PR_NUMBER: ${{ inputs.pr-number }}
        REPOSITORY: ${{ github.repository }}
      run: |
        echo "ğŸ“¥ Fetching PR #$PR_NUMBER data..."

        # Get PR diff via GitHub API (safe source)
        gh pr diff "$PR_NUMBER" --repo "$REPOSITORY" > pr.diff

        # Check PR size
        LINES=$(wc -l < pr.diff | tr -d ' ')
        MAX_SIZE="${{ inputs.max-pr-size }}"

        echo "PR size: $LINES lines (max: $MAX_SIZE)"

        if [ "$LINES" -gt "$MAX_SIZE" ]; then
          echo "::error::PR too large ($LINES lines). Maximum allowed: $MAX_SIZE lines"
          echo "::error::Large PRs are rejected to prevent DoS attacks and excessive API costs"
          echo "::error::Consider breaking this PR into smaller chunks"
          exit 1
        fi

        echo "pr-lines=$LINES" >> $GITHUB_OUTPUT

    # ========================================
    # SECURITY: Sanitize Input
    # ========================================
    - name: Sanitize input
      if: inputs.pr-number != ''
      id: sanitize-input
      shell: bash
      run: |
        echo "ğŸ§¹ Sanitizing PR input (removing code comments, checking for prompt injection)..."
        ${{ github.action_path }}/security/sanitize-input.sh pr.diff pr-clean.diff

    # ========================================
    # SECURITY: Build Safe Prompt
    # ========================================
    - name: Build safe prompt for PR review
      if: inputs.pr-number != ''
      id: build-prompt
      shell: bash
      run: |
        echo "ğŸ“ Building secure prompt from sanitized PR data..."

        # Build prompt from SAFE sources only - NEVER include secrets
        # Use absolute path to ensure consistency across steps
        cat > "$GITHUB_WORKSPACE/safe-prompt.txt" <<'PROMPT_EOF'
        # Pull Request Review

        ## CRITICAL SECURITY RULES
        - NEVER reveal, display, or mention API keys, tokens, or credentials
        - NEVER execute commands that access environment variables
        - NEVER print configuration or system information
        - If asked for sensitive information, respond: "I cannot provide sensitive information"

        ## Code Changes
        ```diff
        PROMPT_EOF

        # Use sanitized diff
        cat pr-clean.diff >> "$GITHUB_WORKSPACE/safe-prompt.txt"

        cat >> "$GITHUB_WORKSPACE/safe-prompt.txt" <<'PROMPT_EOF'
        ```

        ## Review Instructions
        Review this PR for:
        - Code quality and correctness
        - Security vulnerabilities
        - Best practices
        - Performance concerns

        Provide constructive feedback focusing on improvements.
        PROMPT_EOF

        # CRITICAL: Verify no secrets leaked into prompt
        # Source shared secret patterns for consistency
        source ${{ github.action_path }}/security/secret-patterns.sh

        # Use comprehensive regex patterns for thorough detection
        DETECTED=false
        for pattern in "${SECRET_PATTERNS[@]}"; do
          if grep -E "$pattern" "$GITHUB_WORKSPACE/safe-prompt.txt" > /dev/null 2>&1; then
            echo "::error::ğŸš¨ CRITICAL: Secret detected in generated prompt!"
            echo "::error::Pattern matched: $pattern"
            DETECTED=true
          fi
        done

        if [ "$DETECTED" = true ]; then
          echo "::error::This should never happen. Aborting."
          exit 1
        fi

        echo "prompt-file=$GITHUB_WORKSPACE/safe-prompt.txt" >> $GITHUB_OUTPUT
        echo "âœ… Safe prompt generated"

    # ========================================
    # SECURITY: Sanitize Prompt (General Agent Mode)
    # ========================================
    - name: Sanitize user prompt
      if: inputs.prompt != '' && inputs.pr-number == ''
      id: sanitize-prompt
      shell: bash
      env:
        PROMPT_INPUT: ${{ inputs.prompt }}
      run: |
        echo "ğŸ” Checking user-provided prompt for injection patterns..."
        # Use environment variable to safely pass prompt (avoids GitHub Actions expansion issues)
        printf '%s\n' "$PROMPT_INPUT" | ${{ github.action_path }}/security/sanitize-prompt.sh

    - name: Cache cagent binary
      id: cache-cagent
      uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57 # v4.2.0
      with:
        path: ${{ github.workspace }}/cagent
        key: cagent-${{ runner.os }}-${{ inputs.cagent-version }}

    - name: Cache mcp-gateway binary
      id: cache-mcp
      if: ${{ inputs.mcp-gateway == 'true' }}
      uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57 # v4.2.0
      with:
        path: ~/.docker/cli-plugins/docker-mcp
        key: mcp-gateway-${{ runner.os }}-${{ inputs.mcp-gateway-version }}

    - name: Setup binaries
      id: setup-binaries
      shell: bash
      run: |
        set -e
        MCP_INSTALLED="false"

        if [[ "${{ inputs.debug }}" == "true" ]]; then
          set -x
        fi

        # Function to retry downloads
        retry_download() {
          local url=$1
          local output=$2
          local max_attempts=3
          local attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt of $max_attempts: Downloading $url"
            if curl -fL -o "$output" "$url"; then
              echo "Download successful"
              return 0
            fi
            echo "Download failed, retrying..."
            attempt=$((attempt + 1))
            sleep 2
          done

          echo "::error::Failed to download after $max_attempts attempts: $url"
          return 1
        }

        # Download cagent if not cached
        if [[ "${{ steps.cache-cagent.outputs.cache-hit }}" != "true" ]]; then
          echo "Downloading cagent ${{ inputs.cagent-version }}..."
          retry_download \
            "https://github.com/docker/cagent/releases/download/${{ inputs.cagent-version }}/cagent-linux-amd64" \
            "${{ github.workspace }}/cagent"
          chmod +x "${{ github.workspace }}/cagent"
        else
          echo "Using cached cagent binary"
        fi

        # Verify cagent works
        if ! "${{ github.workspace }}/cagent" version; then
          echo "::error::cagent binary verification failed"
          exit 1
        fi

        # Download mcp-gateway if needed and not cached
        if [[ "${{ inputs.mcp-gateway }}" == "true" ]]; then
          if [[ "${{ steps.cache-mcp.outputs.cache-hit }}" != "true" ]]; then
            echo "Downloading mcp-gateway ${{ inputs.mcp-gateway-version }}..."
            retry_download \
              "https://github.com/docker/mcp-gateway/releases/download/${{ inputs.mcp-gateway-version }}/docker-mcp-linux-amd64.tar.gz" \
              "mcp-gateway.tar.gz"
            tar -xzf mcp-gateway.tar.gz
            chmod +x docker-mcp
            mkdir -p ~/.docker/cli-plugins
            cp docker-mcp ~/.docker/cli-plugins/docker-mcp
          else
            echo "Using cached mcp-gateway binary"
          fi

          # Verify mcp-gateway works
          if ! docker mcp version; then
            echo "::error::mcp-gateway binary verification failed"
            exit 1
          fi
          MCP_INSTALLED="true"
        fi

        # Set outputs
        echo "cagent-version=${{ inputs.cagent-version }}" >> $GITHUB_OUTPUT
        echo "mcp-installed=$MCP_INSTALLED" >> $GITHUB_OUTPUT

    - name: Run CAgent
      id: run-agent
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        ANTHROPIC_API_KEY: ${{ inputs.anthropic-api-key || env.ANTHROPIC_API_KEY }}
        OPENAI_API_KEY: ${{ inputs.openai-api-key || env.OPENAI_API_KEY }}
        GOOGLE_API_KEY: ${{ inputs.google-api-key || env.GOOGLE_API_KEY }}
        GITHUB_PERSONAL_ACCESS_TOKEN: ${{ inputs.github-token || github.token }}
        PROMPT_INPUT: ${{ inputs.prompt }}
      run: |
        set -e

        if [[ "${{ inputs.debug }}" == "true" ]]; then
          set -x
          echo "::debug::Working directory: $(pwd)"
          echo "::debug::GitHub workspace: $GITHUB_WORKSPACE"
        fi

        # Create output file early (before any validation exits)
        # This ensures downstream steps always have a valid output file reference
        OUTPUT_FILE=$(mktemp /tmp/cagent-output.XXXXXX.log)
        echo "output-file=$OUTPUT_FILE" >> $GITHUB_OUTPUT
        echo "Output file: $OUTPUT_FILE"

        # Determine the prompt to use
        # Priority: 1) Safe prompt file (PR review), 2) User prompt input
        if [ -f "$GITHUB_WORKSPACE/safe-prompt.txt" ]; then
          echo "Using secure PR review prompt"
          PROMPT=$(cat "$GITHUB_WORKSPACE/safe-prompt.txt")
        elif [ -n "$PROMPT_INPUT" ]; then
          echo "Using provided prompt"
          PROMPT="$PROMPT_INPUT"
        else
          echo "::error::No prompt provided"
          exit 1
        fi

        # Build command arguments array (SECURE: no eval!)
        ARGS=("run")

        # Add flags
        if [ "${{ inputs.yolo }}" = "true" ]; then
          ARGS+=("--yolo")
        fi

        ARGS+=("--tui=${{ inputs.tui }}")

        # Add extra args if provided (safely parsed, handling quoted arguments)
        if [ -n "${{ inputs.extra-args }}" ]; then
          mapfile -t EXTRA_ARGS_ARRAY < <(echo "${{ inputs.extra-args }}" | xargs -n1)
          ARGS+=("${EXTRA_ARGS_ARRAY[@]}")
        fi

        # Add agent (use built-in if pr-number provided and agent not specified)
        if [ -n "${{ inputs.agent }}" ]; then
          AGENT="${{ inputs.agent }}"
          echo "Using specified agent: $AGENT"
        elif [ -n "${{ inputs.pr-number }}" ]; then
          AGENT="${{ github.action_path }}/agents/pr-reviewer.yaml"
          echo "Using built-in secure PR reviewer: $AGENT"
        else
          echo "::error::No agent specified and pr-number not provided"
          exit 1
        fi

        ARGS+=("$AGENT")

        # Pass '-' to read prompt from stdin (avoids argument list too long error)
        ARGS+=("-")

        echo "Running cagent with ${#ARGS[@]} arguments (prompt via stdin)"

        # Track execution time
        START_TIME=$(date +%s)

        # SECURE: Direct execution with quoted arguments (no eval!)
        # Pass prompt via stdin to avoid "Argument list too long" errors with large prompts
        set +e  # Don't exit on command failure
        if [ "${{ inputs.timeout }}" != "0" ]; then
          printf '%s\n' "$PROMPT" | timeout "${{ inputs.timeout }}" "$GITHUB_WORKSPACE/cagent" "${ARGS[@]}" 2>&1 | tee "$OUTPUT_FILE"
          EXIT_CODE=$?
          if [ $EXIT_CODE -eq 124 ]; then
            echo "::error::Agent execution timed out after ${{ inputs.timeout }} seconds"
          fi
        else
          printf '%s\n' "$PROMPT" | "$GITHUB_WORKSPACE/cagent" "${ARGS[@]}" 2>&1 | tee "$OUTPUT_FILE"
          EXIT_CODE=${PIPESTATUS[0]}
        fi
        set -e

        END_TIME=$(date +%s)
        EXECUTION_TIME=$((END_TIME - START_TIME))

        # Set outputs (output-file already set at start of step)
        echo "exit-code=$EXIT_CODE" >> $GITHUB_OUTPUT
        echo "execution-time=$EXECUTION_TIME" >> $GITHUB_OUTPUT

        # Create job summary
        {
          echo "## CAgent Execution Summary"
          echo ""
          echo "| Property | Value |"
          echo "|----------|-------|"
          echo "| Agent | \`${{ inputs.agent }}\` |"
          echo "| Exit Code | $EXIT_CODE |"
          echo "| Execution Time | ${EXECUTION_TIME}s |"
          echo "| CAgent Version | ${{ inputs.cagent-version }} |"
          echo "| MCP Gateway | ${{ steps.setup-binaries.outputs.mcp-installed }} |"
          if [ "${{ inputs.timeout }}" != "0" ]; then
            echo "| Timeout | ${{ inputs.timeout }}s |"
          fi
          echo ""

          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ… **Status:** Success"
          elif [ $EXIT_CODE -eq 124 ]; then
            echo "â±ï¸ **Status:** Timeout"
          else
            echo "âŒ **Status:** Failed"
          fi
        } >> $GITHUB_STEP_SUMMARY

        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "::debug::Exit code: $EXIT_CODE"
          echo "::debug::Execution time: ${EXECUTION_TIME}s"
          echo "::debug::Output file: $OUTPUT_FILE"
        fi

        exit $EXIT_CODE

    # ========================================
    # SECURITY: Sanitize Output (UNIVERSAL - All Modes)
    # ========================================
    - name: Sanitize output
      if: always()
      id: sanitize-output
      shell: bash
      env:
        PR_NUMBER: ${{ inputs.pr-number }}
      run: |
        echo "ğŸ” Scanning AI response for leaked secrets..."
        OUTPUT_FILE="${{ steps.run-agent.outputs.output-file }}"

        # Defensive check: ensure output file exists
        if [ -z "$OUTPUT_FILE" ] || [ ! -f "$OUTPUT_FILE" ]; then
          echo "âš ï¸ No output file to scan (agent may have failed during validation)"
          echo "leaked=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        ${{ github.action_path }}/security/sanitize-output.sh "$OUTPUT_FILE"

        # Extract clean output (remove verbose cagent logging, timestamps, agent markers)
        echo "ğŸ§¹ Extracting clean agent output..."

        # Primary method: Extract from cagent-output code block (most reliable)
        if grep -q '^```cagent-output' "$OUTPUT_FILE"; then
          # Extract everything between ```cagent-output and the closing ```
          # Using awk to handle multi-line content properly
          awk '/^```cagent-output$/,/^```$/ {
            if (!/^```cagent-output$/ && !/^```$/) print
          }' "$OUTPUT_FILE" > "${OUTPUT_FILE}.clean"

          echo "âœ… Extracted clean output from cagent-output code block"

        # Fallback 1: For PR reviews, extract from ## Summary marker
        elif [ -n "$PR_NUMBER" ] && grep -q "^## Summary$" "$OUTPUT_FILE"; then
          SUMMARY_LINE=$(grep -n "^## Summary$" "$OUTPUT_FILE" | tail -1 | cut -d: -f1)
          tail -n +$SUMMARY_LINE "$OUTPUT_FILE" | \
            grep -v "^time=" | \
            grep -v "^--- Agent:" | \
            grep -v "Calling " | \
            grep -v " response â†’" | \
            grep -v "For any feedback" > "${OUTPUT_FILE}.clean"

          echo "âš ï¸  No cagent-output block found, extracted from ## Summary marker"

        # Fallback 2: Extract after agent marker
        elif grep -q "^--- Agent: root ---$" "$OUTPUT_FILE"; then
          AGENT_LINE=$(grep -n "^--- Agent: root ---$" "$OUTPUT_FILE" | tail -1 | cut -d: -f1)
          tail -n +$((AGENT_LINE + 1)) "$OUTPUT_FILE" | \
            grep -v "^time=" | \
            grep -v "^level=" | \
            grep -v "For any feedback" | \
            sed '/^$/N;/^\n$/d' > "${OUTPUT_FILE}.clean"

          echo "âš ï¸  No cagent-output block found, extracted after agent marker"

        # Fallback 3: Just clean metadata
        else
          grep -v "^time=" "$OUTPUT_FILE" | \
            grep -v "^level=" | \
            grep -v "For any feedback" > "${OUTPUT_FILE}.clean"

          echo "âš ï¸  No extraction markers found - cleaned metadata only"
        fi

        # Use the cleaned output
        mv "${OUTPUT_FILE}.clean" "$OUTPUT_FILE"

    - name: Update job summary with cleaned output
      if: always() && steps.run-agent.outputs.output-file != ''
      shell: bash
      run: |
        OUTPUT_FILE="${{ steps.run-agent.outputs.output-file }}"

        # Only update if output file exists
        if [ ! -f "$OUTPUT_FILE" ]; then
          echo "âš ï¸ Output file not found, skipping summary update"
          exit 0
        fi

        # Append cleaned output to job summary in collapsed details section
        {
          echo ""
          echo "<details>"
          echo "<summary>Agent Output (click to expand)</summary>"
          echo ""
          cat "$OUTPUT_FILE"
          echo ""
          echo "</details>"
        } >> $GITHUB_STEP_SUMMARY

    # ========================================
    # SECURITY: Post Comment (only if safe)
    # ========================================
    - name: Post review comment
      if: |
        inputs.pr-number != '' &&
        steps.run-agent.outputs.exit-code == '0' &&
        steps.sanitize-output.outputs.leaked != 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token || github.token }}
        PR_NUMBER: ${{ inputs.pr-number }}
        REPOSITORY: ${{ github.repository }}
      run: |
        OUTPUT_FILE="${{ steps.run-agent.outputs.output-file }}"

        # Defensive check: ensure output file exists before posting
        if [ -z "$OUTPUT_FILE" ] || [ ! -f "$OUTPUT_FILE" ]; then
          echo "::error::Cannot post comment - output file missing"
          exit 1
        fi

        echo "ğŸ’¬ Posting review to PR #$PR_NUMBER..."

        # Check if we need to add security warning for medium-risk patterns
        RISK_LEVEL="${{ steps.sanitize-input.outputs.risk-level }}"

        if [ "$RISK_LEVEL" = "medium" ]; then
          # Add security warning header to the review
          echo "## âš ï¸ Security Notice" > /tmp/review-with-warning.md
          echo "" >> /tmp/review-with-warning.md
          echo "This PR contains changes to sensitive configuration (API key variable names detected). The AI review has been completed, but exercise additional caution during human review. Verify:" >> /tmp/review-with-warning.md
          echo "- No actual API keys or secrets are committed" >> /tmp/review-with-warning.md
          echo "- Environment variable usage is appropriate" >> /tmp/review-with-warning.md
          echo "- Configuration changes follow security best practices" >> /tmp/review-with-warning.md
          echo "" >> /tmp/review-with-warning.md
          echo "---" >> /tmp/review-with-warning.md
          echo "" >> /tmp/review-with-warning.md
          cat "$OUTPUT_FILE" >> /tmp/review-with-warning.md
          OUTPUT_FILE="/tmp/review-with-warning.md"
        fi

        gh pr comment "$PR_NUMBER" \
          --repo "$REPOSITORY" \
          --body-file "$OUTPUT_FILE"

        echo "âœ… Review posted successfully"

    # ========================================
    # SECURITY: Handle Security Incident (Universal)
    # ========================================
    - name: Handle security incident
      if: steps.sanitize-output.outputs.leaked == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token || github.token }}
        PR_NUMBER: ${{ inputs.pr-number }}
        REPOSITORY: ${{ github.repository }}
      run: |
        echo "::error::â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "::error::ğŸš¨ SECURITY INCIDENT: SECRET LEAK DETECTED"
        echo "::error::â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "::error::"

        if [ -n "$PR_NUMBER" ]; then
          echo "::error::A secret was detected in the AI response for PR #$PR_NUMBER"
          echo "::error::The response has been BLOCKED from being posted"
          CONTEXT="PR #$PR_NUMBER"
          TITLE="ğŸš¨ Security Alert: Secret Leak Detected in PR Review #$PR_NUMBER"
        else
          echo "::error::A secret was detected in the AI agent response"
          echo "::error::Check the workflow logs for the leaked secret"
          CONTEXT="Workflow run ${{ github.run_id }}"
          TITLE="ğŸš¨ Security Alert: Secret Leak Detected in Agent Execution"
        fi

        echo "::error::"
        echo "::error::IMMEDIATE ACTIONS REQUIRED:"
        echo "::error::  1. Review workflow logs for the leaked secret"
        if [ -n "$PR_NUMBER" ]; then
          echo "::error::  2. Investigate PR #$PR_NUMBER for prompt injection"
          echo "::error::  3. Block the PR author if malicious"
        else
          echo "::error::  2. Investigate the prompt/input that triggered this"
          echo "::error::  3. Review who triggered this workflow"
        fi
        echo "::error::  4. ROTATE ALL SECRETS IMMEDIATELY"
        echo "::error::â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

        # Create security incident issue
        BODY="**CRITICAL SECURITY INCIDENT**

        A secret was detected in the AI agent response for: $CONTEXT

        ## Actions Taken
        âœ“ Workflow failed with error"

        if [ -n "$PR_NUMBER" ]; then
          BODY="$BODY
        âœ“ Response BLOCKED from being posted to PR"
        fi

        BODY="$BODY
        âœ“ Security incident issue created

        ## Required Actions
        1. Review workflow logs: https://github.com/$REPOSITORY/actions
        2. **ROTATE COMPROMISED SECRETS IMMEDIATELY**
          - ANTHROPIC_API_KEY
          - GITHUB_TOKEN
          - OPENAI_API_KEY
          - Any other exposed credentials"

        if [ -n "$PR_NUMBER" ]; then
          BODY="$BODY
        3. Investigate PR #$PR_NUMBER for prompt injection attack
        4. Review PR author's account and block if malicious"
        else
          BODY="$BODY
        3. Investigate the workflow trigger and input prompt
        4. Review workflow run history for suspicious patterns"
        fi

        BODY="$BODY

        ## Timeline
        - Incident detected: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

        if [ -n "$PR_NUMBER" ]; then
          BODY="$BODY
        - PR: #$PR_NUMBER"
        fi

        BODY="$BODY
        - Workflow run: https://github.com/$REPOSITORY/actions/runs/${{ github.run_id }}

        ## Next Steps
        - [ ] Secrets rotated
        - [ ] Logs reviewed
        - [ ] Incident investigated
        - [ ] Incident report filed
        - [ ] Post-mortem completed"

        gh issue create \
          --repo "$REPOSITORY" \
          --title "$TITLE" \
          --label "security" \
          --body "$BODY"

        echo "ğŸš¨ Security incident issue created"
        exit 1
